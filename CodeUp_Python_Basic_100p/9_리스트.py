""" 6092 : [기초-리스트] 이상한 출석 번호 부르기1 """

# 선생님은 출석부를 보고 번호를 부르는데 번호를 무작위(랜덤)으로 부른다.
# 출석 번호를 n번 무작위로 불렀을 때, 각 번호(1 ~ 23)가 불린 횟수를 각각 출력해보자.

# 참고
# - d = []           #어떤 데이터 목록(list) 을 순서대로 저장하기 위해 아무것도 없는 리스트 변수 만들기
# - d.append(값)      #d 리스트의 마지막에 원하는 값을 추가(append)해 넣음
# - d[a[i]] += 1     #2중 리스트 참조 : 만약 a[i]의 값이 1이었다면? d[1] += 1 이 실행되는 것이다. 1번 카운트 1개 증가..

# n = int(input())
# a = input().split()
# for i in range(n) :
#   a[i] = int(a[i])
# d = []
# for i in range(24) :
#   d.append(0)
# for i in range(n) :
#   d[a[i]] += 1
# for i in range(1, 24) :
#   print(d[i], end=' ')

#
#
#
#
""" for 문 안에 range 범위 증감 방향 바꾸기 """

""" 6093 : [기초-리스트] 이상한 출석 번호 부르기2 """

# 선생님은 수업을 시작하기 전에 무작위(랜덤)으로 출석을 부른다.
# 영일이는 선생님이 부른 번호들을 기억하고 있다가 거꾸로 불러보는 것을 해보고 싶어졌다.

# 출석 번호를 n번 무작위로 불렀을 때, 부른 번호를 거꾸로 출력해 보자.

# 번호를 부른 순서를 리스트에 순서대로 기록해 두었다가, 기록한 값들을 거꾸로 출력하면 된다.
# range(시작, 끝, 증감) #시작 수는 포함, 끝 수는 포함하지 않음. [시작, 끝)
# range(n-1, -1, -1) #n-1, n-2, ..., 3, 2, 1, 0

# n = int(input())
# a = input().split(' ')
# for i in range(n) :
#   a[i] = int(a[i])
# for i in range(n-1, -1, -1) :  # n-1 부터 -1직전(0)까지 -1씩 증감하면서 반복
#   print(a[i], end=' ')

#
#
#
#

""" [기초-리스트] 이상한 출석 번호 부르기3 """

# 출석 번호를 다 부르지는 않은 것 같은데... 가장 빠른 번호가 뭐였지?

# 출석 번호를 n번 무작위로 불렀을 때, 가장 빠른 번호를 출력해 보자.

# 단,
# 첫 번째 번호와 마지막 번호가 몇 번인지는 아무도 모른다.
# 음수(-) 번호, 0번 번호도 있을 수 있다.

# 참고
# 리스트에 출석 번호를 기록해 두었다가, 그 중에서 가장 작은 값을 찾아내면 된다.
# 그런데, 가장 작은 값은 어떻게 어떤 것과 비교하고, 어떻게 찾아야 할까?

# n = int(input())
# a = input().split()
# min = a[0] = int(a[0])
# for i in range(1, n) :
#    if min > int(a[i]) :
#      min = int(a[i])
# print(min)

#
#
#
#

""" 다차원 리스트 만들기 """

""" 6095 : [기초-리스트] 바둑판에 흰 돌 놓기 """

# 바둑판(19 * 19)에 n개의 흰 돌을 놓는다고 할 때,
# n개의 흰 돌이 놓인 위치를 출력하는 프로그램을 작성해보자.

# 입력
# 바둑판에 올려 놓을 흰 돌의 개수(n)가 첫 줄에 입력된다.
# 둘째 줄 부터 n+1 번째 줄까지 힌 돌을 놓을 좌표(x, y)가 n줄 입력된다.
# n은 10이하의 자연수이고 x, y 좌표는 1 ~ 19 까지이며, 똑같은 좌표는 입력되지 않는다.

# 참고
# 2차원 리스트 만드는 법
# 리스트이름[번호][번호] 형식으로 저장되어있는 값을 읽고 쓸 수 있고, 더 확장한 n차원의 리스트도 만들 수 있다.

# d=[]
# for i in range(20) :
#   d.append([])
#   for j in range(20) :
#     d[i].append(0)

# 위와 같이, 모두 0이 채워진 2차원 리스트를 만드는 코드를 아래와 같은 방법으로 짧게 만들 수도 있다.
# ... [0 for j in range(20)]  #20개의 0이 들어간 [0, 0, 0, ... , 0, 0, 0] 리스트
# 아래처럼 작성하면 위와 같은 리스트가 20개가 들어간 리스트를 한 번에 만들어 준다.

# d = [[0 for j in range(20)] for i in range(20)]

# 이러한 리스트 생성 방식을 List Comprehensions 라고 한다.

# d = []
# """
#   for i in range(20) :
#     d.append([])
#     for j in range(20) :
#       d[i].append(0)   # 로도 할 수 있지만
# """
""" 
  d = [ [0 for j in range(20) ] for i in range(20) ]  

  # 이게 더 짧다 : 리스트 컴프레헨션 방식
"""

# n = int(input())
# for i in range(n) :
#   x, y = map(int, input().split())
#   d[x][y] = 1

# for i in range(1, 20) :
#   for j in range(1, 20) :
#     print(d[i][j], end=' ')
#   print()

#
#
#
#

""" 6096 : [기초-리스트] 바둑알 십자 뒤집기 """

# 부모님을 기다리던 영일이는 검정/흰 색 바둑알을 바둑판에 꽉 채워 깔아 놓고 놀다가...

# "십(+)자 뒤집기를 해볼까?"하고 생각했다.

# 십자 뒤집기는
# 그 위치에 있는 모든 가로줄 돌의 색을 반대(1->0, 0->1)로 바꾼 후,
# 다시 그 위치에 있는 모든 세로줄 돌의 색을 반대로 바꾸는 것이다.
# 어떤 위치를 골라 집자 뒤집기를 하면, 그 위치를 제외한 가로줄과 세로줄의 색이 모두 반대로 바뀐다.

# 바둑판(19 * 19)에 흰 돌(1) 또는 검정 돌(0)이 모두 꽉 채워져 놓여있을 때,
# n개의 좌표를 입력받아 십(+)자 뒤집기한 결과를 출력하는 프로그램을 작성해보자.

# d = [ [ 0 for j in range(19)] for i in range(19)]

# for i in range(len(d)) :
#   a = input().split()
#   for j in range(len(d[i])) :
#     d[i][j] = int(a[j])

# n = int(input())

# for i in range(n) :
#   x, y =  input().split()
#   x = int(x)-1
#   y = int(y)-1

#   for i in range(len(d)) :
#     d[i][y] = d[i][y] ^ 1
#     d[x][i] = d[x][i] ^ 1

# for line in d :
#   for cell in line :
#     print(cell, end=' ')
#   print()

"""
  0->1, 1->0 효율적안로 바꾸는 방법 (if 문 안쓰고)

  1. a = 1 - a
  2. a = int( not bool(a) )
  3. a = a ^ 1
"""

""" 
  리스트 반복시 주의할 점

  d = []

  for i in range(len(d)) :
    d[i] = 0

  for cell in d :
    cell = 0

  반복 인자로 i 쓰면 d 요소가 실제로 변경되지만, 
  cell 사하면 d 서 복사된 cell 변수 값만 바뀜(원본인 d는 수정 안됨)

"""

#
#
#
#

""" 6097 : [기초-리스트] 설탕과자 뽑기 """

# 길이가 다른 몇 개의 막대를 바둑판과 같은 격자판에 놓는데,
# 격자판의 세로(h), 가로(w), 막대의 개수(n), 각 막대의 길이(l),
# 막대를 놓는 방향(d:가로는 0, 세로는 1)과
# 막대를 놓는 막대의 가장 왼쪽 또는 위쪽의 위치(x, y)가 주어질 때,
# 격자판을 채운 막대의 모양을 출력하는 프로그램을 만들어보자.

# 입력
# 첫 줄에 격자판의 세로(h), 가로(w) 가 공백을 두고 입력되고,
# 두 번째 줄에 놓을 수 있는 막대의 개수(n)
# 세 번째 줄부터 각 막대의 길이(l), 방향(d), 좌표(x, y)가 입력된다.
# 1 <= w, h <= 100
# 1 <= n <= 10
# d = 0 or 1
# 1 <= x <= 100-h
# 1 <= y <= 100-w

# 출력
# 모든 막대를 놓은 격자판의 상태를 출력한다.
# 막대에 의해 가려진 경우 1, 아닌 경우 0으로 출력한다.
# 단, 각 숫자는 공백으로 구분하여 출력한다.

# h, w = map(int, input().split())

# board = [ [ 0 for j in range(w) ] for i in range(h) ]

# n = int(input())

# for i in range(n) :
#   l, d, x, y = map(int, input().split())
#   x = x-1
#   y = y-1

#   for j in range(l) :
#     if d == 0 :
#       board[x][y+j] = 1
#     else :
#       board[x+j][y] = 1

# for i in range(h) :
#   for j in range(w) :
#     print(board[i][j], end=' ')
#   print()

#
#
#
#

""" 6098 : [기초-리스트] 성실한 개미 """

# 개미는 오른쪽으로 움직이다가 벽을 만나면 아래쪽으로 움직여 가장 빠른 길로 움직였다.
# (오른쪽에 길이 나타나면 다시 오른쪽으로 움직인다.)

# 미로 상자에 넣은 개미는 먹이를 찾았거나, 더 이상 움직일 수 없을 때까지
# 오른쪽 또는 아래쪽으로만 움직였다.

# 미로 상자의 구조가 0(갈 수 있는 곳), 1(벽 또는 장애물)로 주어지고,
# 먹이가 2로 주어질 때, 성실한 개미의 이동 경로를 예상해보자.

# 단, 맨 아래의 가장 오른쪽에 도착한 경우, 더 이상 움직일 수 없는 경우, 먹이를 찾은 경우에는
# 더이상 이동하지 않고 그 곳에 머무른다고 가정한다.

# 미로 상자의 테두리는 모두 벽으로 되어 있으며,
# 개미집은 반드시 (2, 2)에 존재하기 때문에 개미는 (2, 2)에서 출발한다.

m = [[0 for i in range(10)] for i in range(10)]

for i in range(10):
    a = input().split()
    for j in range(10):
        m[i][j] = int(a[j])

antX = antY = 1
while True:
    if m[antY][antX] == 2:
        m[antY][antX] = 9
        break

    m[antY][antX] = 9

    if m[antY][antX + 1] != 1:
        antX += 1
    else:
        if m[antY + 1][antX] != 1:
            antY += 1
        else:
            break

for i in range(10):
    for j in range(10):
        print(m[i][j], end=' ')
    print()